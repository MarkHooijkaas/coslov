#!/usr/bin/python

from copy import copy
import os
import re
import sys

############################################################
def parse_key(str):
    return re.match("^[^:]*", str).group().strip()

def parse_remainder(str):
    return re.sub("^[^:]*:", "", str).strip()

############################################################

class State:
    def __init__(self, lines, line_index=0, item_index=0):
        self.lines = lines
        self.line_index = line_index
        self.item_index = item_index
        self.ok = True
        self.count = 0
        self.match_count = 0
    def line(self):
        return self.lines[self.line_index].rstrip()
    def nextline(self):
        self.line_index += 1
    def prevline(self):
        self.line_index -= 1


##########################################################################

class Item:
    def __init__(self, options):
        if '?' in options:
            self.min=0
            self.max=1
        elif '*' in options:
            self.min=0
            self.max=99999
        elif '+' in options:
            self.min=1
            self.max=99999
        else:
            self.min=1
            self.max=1
    def show(self, indent):
        print(indent+repr(self))


############################################################

class Line(Item):
    def __init__(self, line):
        if line.startswith("@@"):  # special syntax for line that really starts with a @
            line=line[1:]
            opt=''
        elif line.startswith("@"):
            opt=parse_key(line)[1:]
            line=parse_remainder(line)
        else:
            opt=''
        Item.__init__(self, opt)
        self.line=line.rstrip()

    def match(self, state):
        line = state.line()
        if self._match(line):
            state.nextline()
            return True
        else:
            print(str(state.line_index)+": "+state.line())
            print("expecting: " + str(self))
            return False

    def _match(self, line):
        return self.line == line

    def __repr__(self):
        return "Line(" + self.line + ")"

############################################################

standard_regexps = {
    'time': '[0-2][0-9]:[0-5][0-9]:[0-5][0-9]',
    'date': '[0-9][0-9][0-9][0-9]-[0-1][0-9]:[0-3][0-9]',
    'int': '[1-9][0-9]*',
    'fqdn': '[a-zA-Z-.]*.[a-z][a-z]+',
    'comment': '#.*'
}

_RE_FIND_REGEXPS=re.compile('@<[^>]*>')
class RegexpLine(Line):
    def __init__(self, origline):
        Line.__init__(self, origline)
        prev = 0
        result = ''
        for match in _RE_FIND_REGEXPS.finditer(self.line):
            fixed = self.line[prev:match.start()]
            regexp = self.line[match.start():match.end()]
            prev = match.end()
            result += re.escape(fixed)
            if regexp.startswith("@<'") and regexp.endswith("'>"):
                 result += regexp[3:-2]
            else:
                key = regexp[2:-1]
                result += standard_regexps[key]

        result += self.line[prev:]
        self.matcher=re.compile(result)

    def __repr__(self):
        return "RegexpLine(" + self.matcher.pattern + ")"

    def _match(self, line):
        return self.matcher.match(line)

##########################################################################

class YamlVar(Item):
    def __init__(self, line):
        Item.__init__(self, '')
        self.var = parse_remainder(line).strip()

    def __repr__(self):
        return "YamlVar(" +self.var + ")"

    def match(self, state):
        line = state.line()
        if line.startswith(self.var+":"):
            state.nextline()
            if line.endswith('|'):
                line=state.line()
                indent=' ' * (len(line) - len(line.lstrip()))
                while (line.startswith(indent)):
                    state.nextline()
                    line=state.line()
                state.prevline()
            return True
        else:
            print(str(state.line_index)+": "+state.line())
            print("expecting: " + str(self))
            return False

##########################################################################


class Block(Item):
    def __init__(self, lines, index=0):
        Item.__init__(self, '')  # TODO: parse @block
        self.items = []
        line = ''
        while index < len(lines) and not line.startswith('@end'):
            line = lines[index].rstrip()
            if line.startswith('@block'):
                block = Block(lines, index+1)
                self.items.append(block)
                index += len(block.items)+2
            elif line.startswith('@yaml:'):
                self.items.append(YamlVar(line))
            elif '@<' in line:
                self.items.append(RegexpLine(line))
            else:
                self.items.append(Line(line))
            index += 1

    def show(self, indent=''):
        for i in self.items:
            i.show(indent+'    ')

    def match_line(self, state):
        item = self.items[state.item_index]
        line = ''
        if item.match(state):
            #line_index += linecount
            print("    match: " + state.line())
            state.match_count += 1
            if state.match_count >= item.max:
                state.item_index += 1  # next template item
                state.match_count = 0
        elif state.match_count > 0:  # previous line already matched this item, so maybe the next item is in order
            print "bump!"
            state.match_count = 0
            state.item_index += 1
            self.match_line(state)
        else:  # did not match anything
            print("unexpected: " + line)
            return False
        return True

    def match(self, parent_state):
        state = State(
            parent_state.lines,
            line_index = parent_state.line_index,
            item_index = parent_state.item_index
        )
        print "Entering "+str(state)
        while state.line_index < len(lines):
            print self.items[state.item_index]
            if not self.match_line(state):
                return  False
        return True

############################################################


if __name__ == '__main__':
    lines = open(sys.argv[1]).readlines()
    template = Block(lines)
    template.show()
    print "###############"
    state = State(open(sys.argv[2]).readlines())
    template.match(state)
