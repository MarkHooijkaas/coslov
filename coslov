#!/usr/bin/python

import os
import re

############################################################
def parse_key(str):
    return re.match("^[^:]*", str).group().strip()

def parse_remainder(str):
    return re.sub("^[^:]*:", "", str).strip()

############################################################

class Item:
    def __init__(self, options):
        if '?' in options:
            self.min=0
            self.max=1
        elif '*' in options:
            self.min=0
            self.max=99999
        elif '+' in options:
            self.min=1
            self.max=99999
        else:
            self.min=1
            self.max=1


class Line(Item):
    def __init__(self, line):
        if line.startswith("@@"):  # special syntax for line that really starts with a @
            line=line[1:]
            opt=''
        elif line.startswith("@"):
            opt=parse_key(line)[1:]
            line=parse_remainder(line)
        else:
            opt=''
        Item.__init__(self, opt)
        self.line=line.rstrip()

    def match(self, line):
        return self.line == line

    def __repr__(self):
        return "Line(" + self.line + ")"

standard_regexps = {
    'time': '[0-2][0-9]:[0-5][0-9]:[0-5][0-9]',
    'date': '[0-9][0-9][0-9][0-9]-[0-1][0-9]:[0-3][0-9]',
    'int': '[1-9][0-9]*',
    'fqdn': '[a-zA-Z-.]*.[a-z][a-z]+',
    'comment': '#.*'
}

_RE_FIND_REGEXPS=re.compile('@<[^>]*>')
class RegexpLine(Line):
    def __init__(self, origline):
        Line.__init__(self, origline)
        prev = 0
        result = ''
        for match in _RE_FIND_REGEXPS.finditer(self.line):
            fixed = self.line[prev:match.start()]
            regexp = self.line[match.start():match.end()]
            prev = match.end()
            result += re.escape(fixed)
            if regexp.startswith("@<'") and regexp.endswith("'>"):
                 result += regexp[3:-2]
            else:
                key = regexp[2:-1]
                result += standard_regexps[key]

        result += self.line[prev:]
        self.matcher=re.compile(result)

    def __repr__(self):
        return "RegexpLine(" + self.matcher.pattern + ")"

    def match(self, line):
        return self.matcher.match(line)


class Block(Item):
    def __init__(self,lines):
        Item.__init__(self, '')  # TODO: parse @block
        self.items = []
        for line in lines:
            if '@<' in line:
                self.items.append(RegexpLine(line))
            else:
                self.items.append(Line(line))

    def show(self):
        for i in self.items:
            print i

    def match_line(self, line, item_index, match_count, ok):
        item = self.items[item_index]
        #print("expecting: " + str(item))
        if item.match(line):
            print("    match: " + line)
            match_count += 1
            if match_count >= item.max:
                item_index += 1  # next template item
                match_count = 0
        elif match_count > 0:  # previous line already matched this item, so maybe the next item is in order
            print "bump!"
            item_index, match_count, ok = self.match_line(line, item_index+1, 0, ok)
        else:  # did not match anything
            print("unexpected: " + line)
            ok = False
        return (item_index, match_count, ok)


    def match(self, lines):
        item_index = 0
        match_count = 0
        ok = True
        for line in lines:
            line = line.rstrip()
            item_index, match_count, ok = self.match_line(line, item_index, match_count, ok)
        return ok


if __name__ == '__main__':
    template = Block(open("template"))
    print template
    template.match(open('test'))
