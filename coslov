#!/usr/bin/python

import argparse
import os
import re
import sys

#####################################################################################
class CoslovCli:
    def __init__(self):
        epilogtext = '''
commands:
- coslov check:   check one or more files according to a template

All commands can be abbreviated with the first letter or letters, for example to check:
- coslov c
- coslov ch
- coslov che
- coslov chec
'''

        self.allcommands = "check"
        self.parser = argparse.ArgumentParser(
            description='Configfile and Output Stream Line Oriented Validator',
            epilog=epilogtext,
            formatter_class=argparse.RawTextHelpFormatter)
        self.parser.add_argument('-q', '--quiet', action='store_true', help='show no informational output')
        self.parser.add_argument('-d', '--debug', action='store_true', help='print debug info')
        self.parser.add_argument('command', help=self.allcommands)
        self.parser.add_argument('template', nargs='?', default='template.coslov', help='template file')
        self.parser.add_argument('filename', nargs='?', default=None, help='file to check')
        self.args = self.parser.parse_args()
        self.context = Context(self.args)

    def command(self, name):
        if len(name) < len(self.args.command):
            return False
        return name.startswith(self.args.command)


    def run(self):
        args = self.args
        context = self.context
        if self.command('check'):
            lines = open(args.template).readlines()
            template = Block(lines)
            if args.debug:
                template.show()
            context.debug("###############")
            state = State(args, open(args.filename).readlines())
            return template.match(state)
        else:
            raise SystemExit(
                "Unknown command '%s', must be any of %s or a beginning of those letters, e.g enc for encrypt\n" %
                (self.args.command, self.allcommands)
            )

############################################################
def parse_key(str):
    return re.match("^[^:]*", str).group().strip()

def parse_remainder(str):
    return re.sub("^[^:]*:", "", str).strip()

###########################################################################################
class Context():
    def __init__(self, args):
        self.args = args

    def warning(self, str):
        print(str)

    def verbose(self, str):
        if self.args.quiet:
            return
        print(str)

    def debug(self, str):
        if self.args.quiet:
            return
        if self.args.debug:
            print(str)

############################################################

class State(Context):
    def __init__(self, args, lines, line_index=0):
        Context.__init__(self, args)
        self.lines = lines
        self.line_index = line_index
    def line(self):
        if self.line_index >= len(self.lines):
            return None
        return self.lines[self.line_index].rstrip()
    def nextline(self):
        self.line_index += 1
        return self.line()
    def prevline(self):
        self.line_index -= 1
        return self.line()


##########################################################################

class Item:
    def __init__(self, options):
        if '?' in options:
            self.min=0
            self.max=1
        elif '*' in options:
            self.min=0
            self.max=99999
        elif '+' in options:
            self.min=1
            self.max=99999
        else:
            self.min=1
            self.max=1
    def show(self, indent):
        print(indent+repr(self))


############################################################

class Line(Item):
    def __init__(self, line):
        if line.startswith("@@"):  # special syntax for line that really starts with a @
            line = line[1:]
            opt = ''
        elif line.startswith("@"):
            opt = parse_key(line)[1:]
            line = parse_remainder(line)
        else:
            opt = parse_key(line)
        Item.__init__(self, opt)
        self.line=line.rstrip()

    def match(self, state):
        return self.line == state.line()

    def __repr__(self):
        return "Line(" + self.line + ")"

############################################################

standard_regexps = {
    'time': '[0-2][0-9]:[0-5][0-9]:[0-5][0-9]',
    'date': '[0-9][0-9][0-9][0-9]-[0-1][0-9]:[0-3][0-9]',
    'int': '[1-9][0-9]*',
    'fqdn': '[a-zA-Z0-9.]*.[a-z][a-z]+',
    'ip': '[0-9]+.[0-9]+.[0-9]+.[0-9]+',
    'any': '.*',
    'comment': '#.*'
}

_RE_FIND_REGEXPS=re.compile('@<[^>]*>')
class RegexpLine(Line):
    def __init__(self, origline):
        Line.__init__(self, origline)
        prev = 0
        result = ''
        for match in _RE_FIND_REGEXPS.finditer(self.line):
            fixed = self.line[prev:match.start()]
            regexp = self.line[match.start():match.end()]
            prev = match.end()
            result += re.escape(fixed)
            if regexp.startswith("@<'") and regexp.endswith("'>"):
                 result += regexp[3:-2]
            else:
                key = regexp[2:-1]
                result += standard_regexps[key]

        result += self.line[prev:]
        self.matcher=re.compile(result)

    def __repr__(self):
        return "RegexpLine(" + self.matcher.pattern + ")*"+str(self.max)

    def match(self, state):
        return self.matcher.match(state.line())

##########################################################################

class YamlVar(Item):
    def __init__(self, line):
        Item.__init__(self, parse_key(line[:5]))
        self.var = parse_remainder(line).strip()

    def __repr__(self):
        return "YamlVar(" +self.var + ")"

    def match(self, state):
        line = state.line()
        if line.startswith(self.var+":"):
            if line.endswith('|'):
                line=state.nextline()
                indent=' ' * (len(line) - len(line.lstrip()))
                while (line.startswith(indent)):
                    state.nextline()
                    line=state.line()
                state.prevline()
            return True
        else:
            return False

##########################################################################


class Block(Item):
    def __init__(self, lines, index=0):
        Item.__init__(self, '')  # TODO: parse @block
        self.items = []
        line = ''
        while index < len(lines) and not line.startswith('@end'):
            line = lines[index].rstrip()
            if line.startswith('@block'):
                block = Block(lines, index+1)
                self.items.append(block)
                index += len(block.items)+2
            elif line.startswith('@yaml:'):
                self.items.append(YamlVar(line))
            elif '@<' in line:
                self.items.append(RegexpLine(line))
            else:
                self.items.append(Line(line))
            index += 1

    def show(self, indent=''):
        for i in self.items:
            i.show(indent+'    ')

    def count_matches(self, item, state):
        line = state.line()
        cnt = 0
        while cnt < item.max:
            if not item.match(state):
                return cnt
            line=state.nextline()
            cnt += 1
        return cnt

    def match(self, parent_state):
        state = State(
            parent_state.args,
            parent_state.lines,
            line_index = parent_state.line_index,
        )
        ok = True
        for item in self.items:
            state.debug(str(item.max) + '*' + str(item) )
            cnt=self.count_matches(item, state)
            if cnt < item.min:
                state.warning("expected min=" + str(item.min) + ": " + str(item))
                #state.warning(str(state.line_index)+": "+state.line())
                #state.warning("expecting: " + str(self))
                ok = False
                state.nextline()
            else:
                prefix = str(cnt)
                prefix = prefix+' ' * (5-len(prefix))
                state.verbose(prefix + " match: " + str(item) )
        return ok

############################################################

if __name__ == '__main__':
    CoslovCli().run()
